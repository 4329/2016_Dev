// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "DriveTrain.h"
#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "../Commands/Teleop_Drive.h"


DriveTrain::DriveTrain() : Subsystem("DriveTrain"), Configurable("DriveTrain") {
    rightTalon2 = RobotMap::driveTrainRightTalon2;
    rightTalon1 = RobotMap::driveTrainRightTalon1;
    leftTalon2 = RobotMap::driveTrainLeftTalon2;
    leftTalon1 = RobotMap::driveTrainLeftTalon1;
    robotDrive = RobotMap::driveTrainRobotDrive;

    myCfg.reset(&(Robot::theConfig->_DriveCfg));

	leftMotorOutput = 0.0;
	rightMotorOutput = 0.0;
	positioning = false;
	ldistance = 0.0;
	rdistance = 0.0;
	rZeroPoint = 0.0;
	lZeroPoint = 0.0;
	lLastPosDelta = 0.0;
	rLastPosDelta = 0.0;
	hasMoved = false;
	myType = DriveType_Split;
	lastturn = 0;
	Configure();

	turnController.reset(new PID_Control(std::string("DT_Turn"), (PIDSource *) Robot::sensorPkg->imu->_myIMU.get(), this));
	if (myCfg->RightTalon1_HasSensor)
	{
		linearController.reset(new PID_Control(std::string("DT_Linear"),rightTalon1.get(),&posPID));
		if (myCfg->Right_SensorReversed) posPID.SetReversed(true);
	} else //if (myCfg->DriveTrain_RightTalon2_HasSensor)
	{
		linearController.reset(new PID_Control(std::string("DT_Linear"),rightTalon2.get(),&posPID));
		if (myCfg->Right_SensorReversed) posPID.SetReversed(true);
	}
}


DriveTrain::~DriveTrain()
{

}

void DriveTrain::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
        SetDefaultCommand(new Teleop_Drive());
}


// Put methods for controlling this subsystem
// here. Call these from Commands.

void DriveTrain::RetrieveConfig()
{
    myType = (DriveType) Preferences::GetInstance()->GetInt("DriveTrain::DriveType",(int)DriveType_Split);
}

void DriveTrain::SaveConfig()
{
	Preferences::GetInstance()->PutInt("DriveTrain::DriveType",(int) myType);
}

void DriveTrain::Configure()
{
// Left Side

	if (myCfg->LeftTalon1_Enabled)
	{
        if (myCfg->LeftTalon1_HasSensor)
        {
        	leftTalon1->SetFeedbackDevice(CANTalon::QuadEncoder);
        	leftTalon1->ConfigEncoderCodesPerRev(myCfg->QuadEncoder_CodesPerRev);
			if (myCfg->Left_SensorReversed)
			{
				leftTalon1->SetSensorDirection(true);
			} else
			{
				leftTalon1->SetSensorDirection(false);
			}
        }
        if (myCfg->LeftTalon1_EnablePID)
        {
        	leftTalon1->SelectProfileSlot(0);
        	leftTalon1->SetP(myCfg->Left_Profile_0_PID_P);
        	leftTalon1->SetI(myCfg->Left_Profile_0_PID_I);
        	leftTalon1->SetD(myCfg->Left_Profile_0_PID_D);
        	leftTalon1->SetF(myCfg->Left_Profile_0_PID_F);
			if (myCfg->Left_Profile_0_EnableCLRampRate)
			{
				leftTalon1->SetCloseLoopRampRate(myCfg->Left_Profile_0_CLRampRate);
			}

			leftTalon1->SetIzone(myCfg->Left_Profile_0_IZone);

			leftTalon1->SelectProfileSlot(1);
			leftTalon1->SetP(myCfg->Left_Profile_1_PID_P);
			leftTalon1->SetI(myCfg->Left_Profile_1_PID_I);
			leftTalon1->SetD(myCfg->Left_Profile_1_PID_D);
			leftTalon1->SetF(myCfg->Left_Profile_1_PID_F);
			if (myCfg->Left_Profile_1_EnableCLRampRate)
			{
				leftTalon1->SetCloseLoopRampRate(myCfg->Left_Profile_1_CLRampRate);
			}

			leftTalon1->SetIzone(myCfg->Left_Profile_1_IZone);
        }

		if(myCfg->EnableVoltRampRate)
		{
			leftTalon1->SetVoltageRampRate(myCfg->VoltRampRate);
		}

		if(myCfg->LeftTalon1_Slaved)
		{
			leftTalon1->SetControlMode(CANSpeedController::kFollower);
			leftTalon1->Set(myCfg->LeftTalon1_MasterCANID);
		}

	}

	if (myCfg->LeftTalon2_Enabled)
	{
        if (myCfg->LeftTalon2_HasSensor)
        {
        	leftTalon2->SetFeedbackDevice(CANTalon::QuadEncoder);
        	leftTalon2->ConfigEncoderCodesPerRev(myCfg->QuadEncoder_CodesPerRev);
			if (myCfg->Left_SensorReversed)
			{
				leftTalon2->SetSensorDirection(true);
			} else
			{
				leftTalon2->SetSensorDirection(false);
			}
        }
        if (myCfg->LeftTalon2_EnablePID)
        {
        	leftTalon2->SelectProfileSlot(0);
        	leftTalon2->SetP(myCfg->Left_Profile_0_PID_P);
        	leftTalon2->SetI(myCfg->Left_Profile_0_PID_I);
        	leftTalon2->SetD(myCfg->Left_Profile_0_PID_D);
        	leftTalon2->SetF(myCfg->Left_Profile_0_PID_F);
			if (myCfg->Left_Profile_0_EnableCLRampRate)
			{
				leftTalon2->SetCloseLoopRampRate(myCfg->Left_Profile_0_CLRampRate);
			}

			leftTalon2->SetIzone(myCfg->Left_Profile_0_IZone);

			leftTalon2->SelectProfileSlot(1);
			leftTalon2->SetP(myCfg->Left_Profile_1_PID_P);
			leftTalon2->SetI(myCfg->Left_Profile_1_PID_I);
			leftTalon2->SetD(myCfg->Left_Profile_1_PID_D);
			leftTalon2->SetF(myCfg->Left_Profile_1_PID_F);
			if (myCfg->Left_Profile_1_EnableCLRampRate)
			{
				leftTalon2->SetCloseLoopRampRate(myCfg->Left_Profile_1_CLRampRate);
			}

			leftTalon2->SetIzone(myCfg->Left_Profile_1_IZone);
        }

		if(myCfg->EnableVoltRampRate)
		{
			leftTalon2->SetVoltageRampRate(myCfg->VoltRampRate);
		}

		if(myCfg->LeftTalon2_Slaved)
		{
			leftTalon2->SetControlMode(CANSpeedController::kFollower);
			leftTalon2->Set(myCfg->LeftTalon2_MasterCANID);
		}
	}

    if (myCfg->LeftTalon2_HasSensor)
    {
    	leftMaster = leftTalon2;
    	leftSlave  = leftTalon1;
    } else
    {
    	leftMaster = leftTalon1;
    	leftSlave  = leftTalon2;
    }

    if(myCfg->Left_Reversed)
    {
    	leftTalon1->SetInverted(true);
    	leftTalon2->SetInverted(true);
    }



// Right Side

	if (myCfg->RightTalon1_Enabled)
	{
        if (myCfg->RightTalon1_HasSensor)
        {
        	rightTalon1->SetFeedbackDevice(CANTalon::QuadEncoder);
        	rightTalon1->ConfigEncoderCodesPerRev(myCfg->QuadEncoder_CodesPerRev);
			if (myCfg->Right_SensorReversed)
			{
				rightTalon1->SetSensorDirection(true);
			} else
			{
				rightTalon1->SetSensorDirection(false);
			}
        }
        if (myCfg->RightTalon1_EnablePID)
        {
        	rightTalon1->SelectProfileSlot(0);
        	rightTalon1->SetP(myCfg->Right_Profile_0_PID_P);
        	rightTalon1->SetI(myCfg->Right_Profile_0_PID_I);
        	rightTalon1->SetD(myCfg->Right_Profile_0_PID_D);
        	rightTalon1->SetF(myCfg->Right_Profile_0_PID_F);
			if (myCfg->Right_Profile_0_EnableCLRampRate)
			{
				rightTalon1->SetCloseLoopRampRate(myCfg->Right_Profile_0_CLRampRate);
			}

			rightTalon1->SetIzone(myCfg->Right_Profile_0_IZone);

			rightTalon1->SelectProfileSlot(1);
			rightTalon1->SetP(myCfg->Right_Profile_1_PID_P);
			rightTalon1->SetI(myCfg->Right_Profile_1_PID_I);
			rightTalon1->SetD(myCfg->Right_Profile_1_PID_D);
			rightTalon1->SetF(myCfg->Right_Profile_1_PID_F);
			if (myCfg->Right_Profile_1_EnableCLRampRate)
			{
				rightTalon1->SetCloseLoopRampRate(myCfg->Right_Profile_1_CLRampRate);
			}

			rightTalon1->SetIzone(myCfg->Right_Profile_1_IZone);
        }

		if(myCfg->EnableVoltRampRate)
		{
			rightTalon1->SetVoltageRampRate(myCfg->VoltRampRate);
		}

		if(myCfg->RightTalon1_Slaved)
		{
			rightTalon1->SetControlMode(CANSpeedController::kFollower);
			rightTalon1->Set(myCfg->RightTalon1_MasterCANID);
		}
	}

	if (myCfg->RightTalon2_Enabled)
	{
        if (myCfg->RightTalon2_HasSensor)
        {
        	rightTalon2->SetFeedbackDevice(CANTalon::QuadEncoder);
        	rightTalon2->ConfigEncoderCodesPerRev(myCfg->QuadEncoder_CodesPerRev);
			if (myCfg->Right_SensorReversed)
			{
				rightTalon2->SetSensorDirection(true);
			} else
			{
				rightTalon2->SetSensorDirection(false);
			}
        }
        if (myCfg->RightTalon2_EnablePID)
        {
        	rightTalon2->SelectProfileSlot(0);
        	rightTalon2->SetP(myCfg->Right_Profile_0_PID_P);
        	rightTalon2->SetI(myCfg->Right_Profile_0_PID_I);
        	rightTalon2->SetD(myCfg->Right_Profile_0_PID_D);
        	rightTalon2->SetF(myCfg->Right_Profile_0_PID_F);
			if (myCfg->Right_Profile_0_EnableCLRampRate)
			{
				rightTalon2->SetCloseLoopRampRate(myCfg->Right_Profile_0_CLRampRate);
			}

			rightTalon2->SetIzone(myCfg->Right_Profile_0_IZone);

			rightTalon2->SelectProfileSlot(1);
			rightTalon2->SetP(myCfg->Right_Profile_1_PID_P);
			rightTalon2->SetI(myCfg->Right_Profile_1_PID_I);
			rightTalon2->SetD(myCfg->Right_Profile_1_PID_D);
			rightTalon2->SetF(myCfg->Right_Profile_1_PID_F);
			if (myCfg->Right_Profile_1_EnableCLRampRate)
			{
				rightTalon2->SetCloseLoopRampRate(myCfg->Right_Profile_1_CLRampRate);
			}

			rightTalon2->SetIzone(myCfg->Right_Profile_1_IZone);
        }

		if(myCfg->EnableVoltRampRate)
		{
			rightTalon2->SetVoltageRampRate(myCfg->VoltRampRate);
		}
		if(myCfg->RightTalon2_Slaved)
		{
			rightTalon2->SetControlMode(CANSpeedController::kFollower);
			rightTalon2->Set(myCfg->RightTalon2_MasterCANID);
		}
	}
	if (myCfg->RightTalon2_HasSensor)
	{
		rightMaster = rightTalon2;
		rightSlave =  rightTalon1;
	} else
	{
		rightMaster = rightTalon1;
		rightSlave  = rightTalon2;
	}

    if(myCfg->Right_Reversed)
    {
    	rightTalon1->SetInverted(true);
    	rightTalon2->SetInverted(true);
    }

}

void DriveTrain::LiveConfigure()
{
	RetrieveConfig();
	Configure();
	turnController->LiveConfigure();
	linearController->LiveConfigure();
}

void DriveTrain::Stop()
{
	leftTalon1->Disable();
	leftTalon2->Disable();
	rightTalon1->Disable();
	rightTalon2->Disable();
	if (turnController->IsEnabled()) turnController->Disable();
	if (linearController->IsEnabled()) linearController->Disable();
	if (posPID.IsEnabled()) posPID.Disable();
	positioning = false;
	turning = false;
}

void DriveTrain::Set_PositionMode()
{
/*
	Zero_Encoders();

	leftTalon1->Set(lZeroPoint);
	leftTalon2->Set(lZeroPoint);
	rightTalon1->Set(rZeroPoint);
	rightTalon2->Set(rZeroPoint);


*/
	leftMaster->SelectProfileSlot(1);
	rightMaster->SelectProfileSlot(1);

	leftMaster->SetControlMode(CANSpeedController::kPosition);
	rightMaster->SetControlMode(CANSpeedController::kPosition);
	leftSlave->SetControlMode(CANSpeedController::kFollower);
	rightSlave->SetControlMode(CANSpeedController::kFollower);

	leftMaster->SetAllowableClosedLoopErr(myCfg->PID_CL_Allowable_Error);
	rightMaster->SetAllowableClosedLoopErr(myCfg->PID_CL_Allowable_Error);

	Zero_DriveEncoders();
	leftMaster->ClearError();
	rightMaster->ClearError();

	leftMaster->ClearIaccum();
	rightMaster->ClearIaccum();

	leftMaster->Set(0);
	rightMaster->Set(0);

	leftSlave->EnableControl();
	rightSlave->EnableControl();

	leftMaster->EnableControl();
	rightMaster->EnableControl();

}

void DriveTrain::Set_VoltageMode()
{
/*


*/
	leftMaster->SelectProfileSlot(0);
	rightMaster->SelectProfileSlot(0);

	Zero_DriveEncoders();

    leftMaster->SetControlMode(CANSpeedController::kPercentVbus);
    rightMaster->SetControlMode(CANSpeedController::kPercentVbus);
	leftSlave->SetControlMode(CANSpeedController::kFollower);
	rightSlave->SetControlMode(CANSpeedController::kFollower);

	leftSlave->EnableControl();
	rightSlave->EnableControl();

    leftMaster->Set(0);
    rightMaster->Set(0);

    leftMaster->EnableControl();
    rightMaster->EnableControl();
}

void DriveTrain::Zero_Encoders()
{
	lZeroPoint = leftMaster->GetPosition();
	rZeroPoint = rightMaster->GetPosition();

	lLastPosDelta = 0.0;
	rLastPosDelta = 0.0;
	hasMoved = false;
}

void DriveTrain::Zero_DriveEncoders()
{
	leftMaster->SetEncPosition(0);
	leftMaster->SetPosition(0.0);
	rightMaster->SetEncPosition(0);
	rightMaster->SetPosition(0.0);
	Zero_Encoders();
}

float DriveTrain::Limit(float num)
{
	if (num > 1.0)
	{
		return 1.0;
	}
	if (num < -1.0)
	{
		return -1.0;
	}
	return num;
}


bool DriveTrain::AtCommandedPosition()
{
	//if (!positioning) return true;
/*	double cpos = Master->GetPosition();
	double delta;

	if (cpos > distance)
	{
		delta = cpos - distance;
	} else
	{
		delta = distance - cpos;
	}

	//printf("sd:acp cpos %f distance %f cle %f poserr %d\n",cpos,distance, abs(cpos - distance),posErr);
	if (abs(delta) <= posErr )
	{
		printf("SD:ACP return cpos %f distance %f", cpos, distance);
		return true;
	}*/
	if (!yawLock)
	{
		double current = rightMaster->GetPosition();
		double lastSet = rightMaster->GetSetpoint();
		double delta;

		if (current > lastSet)
		{
			delta = current - lastSet;
		} else
		{
			delta = lastSet - current;
		}
		if (abs(delta) <= myCfg->PID_CL_Allowable_Error)
		{
			return true;
		}
		return false;
	} else
	{
		return linearController->OnTarget();
	}
	return false;
}

/*
 * Notes for Automodes
 * To turn only:
 * 1) Invoke Enable_Auto_Mode
 * 2) Invoke AutoDrive_Rotate in the execute and poll OnTarget in is finished.
 *
 * To move:
 * 1) Enable_Auto_Mode
 * 2) Invoke AutoDrive_SetYawLock(true)
 * 3)
 */



void DriveTrain::Enable_Auto_Mode()
{
	autoEnabled = true;
	Zero_DriveEncoders();
	Robot::sensorPkg->imu->ZeroYaw();
	Robot::sensorPkg->imu->ResetDisplacement();
}

void DriveTrain::AutoDrive_SetYawLock(bool lockYaw)
{
	yawLock = lockYaw;
	if (yawLock)
	{
		holdYaw = Robot::sensorPkg->imu->GetYaw();
		if (yawFlipped)
		{
			holdYaw = 0 - holdYaw;
		}
		turnController->SetSetpoint(holdYaw);
		turnController->Enable();
	} else
	{
		holdYaw = 0;
		if (turnController->IsEnabled()) turnController->Disable();
	}
}

void DriveTrain::AutoDrive_Rotate(float rotate)
{
	if (!turning)
	{
		Zero_DriveEncoders();
		Robot::sensorPkg->imu->ZeroYaw();
		leftMaster->EnableControl();
		rightMaster->EnableControl();
		turnController->SetSetpoint(rotate);
		turnController->Enable();
		turning = true;
	}
}

bool DriveTrain::On_Target()
{
	return turnController->OnTarget();
}

double DriveTrain::Get_PulsesPerInch()
{
	return myCfg->QuadEncoder_CodesPerRev / myCfg->InchesPerRotation;
}

void DriveTrain::AutoDrive_SetDistance(float inches)
{
	float throttle = 0;
	if (!yawLock)
	{
		if (!positioning)
		{
			Zero_DriveEncoders();
			ldistance = (inches / myCfg->InchesPerRotation) * myCfg->QuadEncoder_CodesPerRev;
			if (myCfg->Left_SensorReversed || myCfg->Left_Reversed) ldistance = 0 - ldistance;

			rdistance = (inches / myCfg->InchesPerRotation) * myCfg->QuadEncoder_CodesPerRev;
			if (myCfg->Right_SensorReversed || myCfg->Right_Reversed) rdistance = 0 - rdistance;

			//if (leftMaster->GetPosition())


			printf("direct linear: set right %f  left %f \n",rdistance, ldistance);
			leftMaster->Set(ldistance);
			rightMaster->Set(rdistance);
			leftMaster->EnableControl();
			rightMaster->EnableControl();
			positioning = true;
		}
	} else
	{
		if (!positioning)
		{
			rdistance = (inches / myCfg->InchesPerRotation) * myCfg->QuadEncoder_CodesPerRev;
			if (myCfg->Right_SensorReversed) rdistance = 0 - rdistance;

			printf("yawlock linear: set %f  \n",rdistance);
			linearController->SetSetpoint(rdistance);
			linearController->Enable();
			posPID.Enable();
			leftMaster->EnableControl();
			rightMaster->EnableControl();
			positioning = true;
		} else
		{
			if (posPID.IsEnabled()) throttle = posPID.Get_Output();
			SetDrive_Auto(lastturn, throttle);
		}
	}
}

void DriveTrain::AutoDrive_Move(float throttle)
{
	float limThrottle = Limit(throttle);

	if (rightMaster->GetControlMode() != CANSpeedController::kPercentVbus)
	{
		positioning = false;
		Set_VoltageMode();
	}

	leftMaster->Set(limThrottle);
	rightMaster->Set(limThrottle);
}

void DriveTrain::PIDWrite(float output)
{
	float turn = 0;
	float throttle = 0;

	if (posPID.IsEnabled()) throttle = posPID.Get_Output();

	if (yawFlipped)
	{
		turn = 0 - output;
	} else
	{
		turn = output;
	}

	lastturn = turn;
	SetDrive_Auto(turn, throttle);
}

double DriveTrain::Get_CurrentPosition()
{
	return rightMaster->GetPosition();
}


void DriveTrain::Disable_Auto_Mode()
{
	autoEnabled = false;
	if (turnController->IsEnabled()) turnController->Disable();
	if (linearController->IsEnabled()) linearController->Disable();
	if (posPID.IsEnabled()) posPID.Disable();
	Set_VoltageMode();
    lastturn = 0;
	turning = false;
	positioning = false;
}

void DriveTrain::SetDriveType(DriveType type)
{
	myType = type;
	switch (myType)
	{
		case DriveType_Arcade:
			SmartDashboard::PutString("DriveType","Arcade");
			Preferences::GetInstance()->PutInt("DriveTrain::DriveType",(int) myType);
			break;
		case DriveType_Tank:
			SmartDashboard::PutString("DriveType","Tank");
			Preferences::GetInstance()->PutInt("DriveTrain::DriveType",(int) myType);
			break;

		case DriveType_Split:
			SmartDashboard::PutString("DriveType","Split");
			Preferences::GetInstance()->PutInt("DriveTrain::DriveType",(int) myType);
			break;
		default:
			SmartDashboard::PutString("DriveType","Invalid");
			break;
	}
}

void DriveTrain::SetDrive(XBOX_AxisState axisState)
{
	bool highspeed = false;
	if (axisState.RTrigger > 0.0)
	{
		highspeed = true;
	} else
	{
		highspeed = false;
	}

	switch (myType)
	{
	case DriveType_Arcade:
			Robot::driveTrain->SetDrive_Arcade(axisState.Raw_LX, axisState.Raw_LY, highspeed);
		break;

	case DriveType_Tank:
			Robot::driveTrain->SetDrive_Tank(axisState.Raw_RY, axisState.Raw_LY, highspeed);
		break;

	case DriveType_Split:
			Robot::driveTrain->SetDrive_Split(axisState.Raw_LX, axisState.Raw_RY, highspeed);
		break;

	default:

		break;
	}
}


void DriveTrain::SetDrive_Arcade(float x, float y, bool highRate)
{
	float tx, ty;

	tx = Limit(x);
	ty = Limit(y);

    //printf("Arcade Drive: X %f  Y %f\n",tx,ty);


	if (rightTalon1->GetControlMode() != CANSpeedController::kPercentVbus)
	{
		positioning = false;
		Set_VoltageMode();
	}

	if (ty > 0.0)
	{
		if (tx > 0.0)
		{
			leftMotorOutput = ty - tx;
			rightMotorOutput = std::max(ty, tx);
		}
		else if (tx < 0.0)
		{
			leftMotorOutput = std::max(ty, -tx);
			rightMotorOutput = ty + tx;
		} else
		{
			leftMotorOutput = ty;
			rightMotorOutput = ty;
		}
	}
	else
	{
		if (tx > 0.0)
		{
			leftMotorOutput = - std::max(-ty, tx);
			rightMotorOutput = ty + tx;
		}
		else if (tx < 0.0)
		{
			leftMotorOutput = ty - tx;
			rightMotorOutput = - std::max(-ty, -tx);
		} else
		{
			leftMotorOutput = ty;
			rightMotorOutput = ty;
		}
	}

	if (highRate)
	{
		leftTalon1->Set(leftMotorOutput*myCfg->HighSpeed);
		rightTalon1->Set(rightMotorOutput*myCfg->HighSpeed);
	} else
	{
		leftTalon1->Set(leftMotorOutput*myCfg->LowSpeed);
		rightTalon1->Set(rightMotorOutput*myCfg->LowSpeed);
	}
}


void DriveTrain::SetDrive_Tank(float left, float right, bool highRate)
{
	float tx, ty;

	tx = Limit(left);
	ty = Limit(right);

    //printf("Tank Drive: Left %f  Right %f\n",ty,tx);

	leftMotorOutput = tx;
	rightMotorOutput = ty;

	if (highRate)
	{
		leftTalon1->Set(leftMotorOutput*myCfg->HighSpeed);
		rightTalon1->Set(rightMotorOutput*myCfg->HighSpeed);
	} else
	{
		leftTalon1->Set(leftMotorOutput*myCfg->LowSpeed);
		rightTalon1->Set(rightMotorOutput*myCfg->LowSpeed);
	}
}

void DriveTrain::SetDrive_Split(float turn, float throttle, bool highRate)
{
	float tx, ty;

	tx = Limit(turn);
	ty = Limit(throttle);

    //printf("Split Drive: Turn %f  Throttle %f\n",tx,ty);


	if (rightTalon1->GetControlMode() != CANSpeedController::kPercentVbus)
	{
		positioning = false;
		Set_VoltageMode();
	}

	if (ty > 0.0)
	{
		if (tx > 0.0)
		{
			leftMotorOutput = ty - tx;
			rightMotorOutput = std::max(ty, tx);
		}
		else if (tx < 0.0)
		{
			leftMotorOutput = std::max(ty, -tx);
			rightMotorOutput = ty + tx;
		} else
		{
			leftMotorOutput = ty;
			rightMotorOutput = ty;
		}
	}
	else
	{
		if (tx > 0.0)
		{
			leftMotorOutput = - std::max(-ty, tx);
			rightMotorOutput = ty + tx;
		}
		else if (tx < 0.0)
		{
			leftMotorOutput = ty - tx;
			rightMotorOutput = - std::max(-ty, -tx);
		} else
		{
			leftMotorOutput = ty;
			rightMotorOutput = ty;
		}
	}

	if (highRate)
	{
		leftTalon1->Set(leftMotorOutput*myCfg->HighSpeed);
		rightTalon1->Set(rightMotorOutput*myCfg->HighSpeed);
	} else
	{
		leftTalon1->Set(leftMotorOutput*myCfg->LowSpeed);
		rightTalon1->Set(rightMotorOutput*myCfg->LowSpeed);
	}
}


void DriveTrain::SetDrive_Auto(float turn, float throttle)
{
	float tx, ty;

	tx = Limit(turn);
	ty = Limit(throttle);

    //printf("Auto Drive: Turn %f  Throttle %f\n",tx,ty);


	if (rightTalon1->GetControlMode() != CANSpeedController::kPercentVbus)
	{
		positioning = false;
		Set_VoltageMode();
	}

	if (ty > 0.0)
	{
		if (tx > 0.0)
		{
			leftMotorOutput = ty - tx;
			rightMotorOutput = std::max(ty, tx);
		}
		else if (tx < 0.0)
		{
			leftMotorOutput = std::max(ty, -tx);
			rightMotorOutput = ty + tx;
		} else
		{
			leftMotorOutput = ty;
			rightMotorOutput = ty;
		}
	}
	else
	{
		if (tx > 0.0)
		{
			leftMotorOutput = - std::max(-ty, tx);
			rightMotorOutput = ty + tx;
		}
		else if (tx < 0.0)
		{
			leftMotorOutput = ty - tx;
			rightMotorOutput = - std::max(-ty, -tx);
		} else
		{
			leftMotorOutput = ty;
			rightMotorOutput = ty;
		}
	}
	leftMaster->Set(leftMotorOutput);
	rightMaster->Set(rightMotorOutput);
}
