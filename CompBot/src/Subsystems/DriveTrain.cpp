// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "DriveTrain.h"
#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "../Commands/Teleop_Drive.h"
#include "../Robot.h"

DriveTrain::DriveTrain() : Subsystem("DriveTrain"), Configurable("DriveTrain") {
    rightTalon2 = RobotMap::driveTrainRightTalon2;
    rightTalon1 = RobotMap::driveTrainRightTalon1;
    leftTalon2 = RobotMap::driveTrainLeftTalon2;
    leftTalon1 = RobotMap::driveTrainLeftTalon1;
    robotDrive = RobotMap::driveTrainRobotDrive;

    myCfg.reset(&(Robot::theConfig->_DriveCfg));

	leftMotorOutput = 0.0;
	rightMotorOutput = 0.0;
	positioning = false;
	ldistance = 0.0;
	rdistance = 0.0;
	rZeroPoint = 0.0;
	lZeroPoint = 0.0;
	lLastPosDelta = 0.0;
	rLastPosDelta = 0.0;
	hasMoved = false;
	myType = DriveType_Split;
	lastturn = 0;
	Configure();
/*
	turnController.reset(new PID_Control(std::string("DT_Turn"), (PIDSource *) Robot::sensorPkg->imu->_myIMU.get(), this));
	if (myCfg->RightTalon1_HasSensor)
	{
		linearController.reset(new PID_Control(std::string("DT_Linear"),rightTalon1.get(),&posPID));
		if (myCfg->Right_SensorReversed) posPID.SetReversed(true);
	} else //if (myCfg->DriveTrain_RightTalon2_HasSensor)
	{
		linearController.reset(new PID_Control(std::string("DT_Linear"),rightTalon2.get(),&posPID));
		if (myCfg->Right_SensorReversed) posPID.SetReversed(true);
	}
	*/
}


DriveTrain::~DriveTrain()
{

}

void DriveTrain::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
        SetDefaultCommand(new Teleop_Drive());
}


// Put methods for controlling this subsystem
// here. Call these from Commands.

void DriveTrain::RetrieveConfig()
{
    myType = (DriveType) Preferences::GetInstance()->GetInt("DriveTrain::DriveType",(int)DriveType_Split);
}

void DriveTrain::SaveConfig()
{
	Preferences::GetInstance()->PutInt("DriveTrain::DriveType",(int) myType);
}

void DriveTrain::Configure()
{
// Left Side

	if (myCfg->LeftTalon1_Enabled)
	{
        if (myCfg->LeftTalon1_HasSensor)
        {
        	leftTalon1->SetFeedbackDevice(CANTalon::QuadEncoder);
        	leftTalon1->ConfigEncoderCodesPerRev(myCfg->QuadEncoder_CodesPerRev);
			if (myCfg->Left_SensorReversed)
			{
				leftTalon1->SetSensorDirection(true);
			} else
			{
				leftTalon1->SetSensorDirection(false);
			}
        }
        if (myCfg->LeftTalon1_EnablePID)
        {
        	leftTalon1->SelectProfileSlot(0);
        	leftTalon1->SetP(myCfg->Left_Profile_0_PID_P);
        	leftTalon1->SetI(myCfg->Left_Profile_0_PID_I);
        	leftTalon1->SetD(myCfg->Left_Profile_0_PID_D);
        	leftTalon1->SetF(myCfg->Left_Profile_0_PID_F);
			if (myCfg->Left_Profile_0_EnableCLRampRate)
			{
				leftTalon1->SetCloseLoopRampRate(myCfg->Left_Profile_0_CLRampRate);
			}

			leftTalon1->SetIzone(myCfg->Left_Profile_0_IZone);

			leftTalon1->SelectProfileSlot(1);
			leftTalon1->SetP(myCfg->Left_Profile_1_PID_P);
			leftTalon1->SetI(myCfg->Left_Profile_1_PID_I);
			leftTalon1->SetD(myCfg->Left_Profile_1_PID_D);
			leftTalon1->SetF(myCfg->Left_Profile_1_PID_F);
			if (myCfg->Left_Profile_1_EnableCLRampRate)
			{
				leftTalon1->SetCloseLoopRampRate(myCfg->Left_Profile_1_CLRampRate);
			}

			leftTalon1->SetIzone(myCfg->Left_Profile_1_IZone);
        }

		if(myCfg->EnableVoltRampRate)
		{
			leftTalon1->SetVoltageRampRate(myCfg->VoltRampRate);
			printf("Enabling Voltage Ramp Rate Left Talon 1 %f \n",myCfg->VoltRampRate);
		}

		if(myCfg->LeftTalon1_Slaved)
		{
			leftTalon1->SetControlMode(CANSpeedController::kFollower);
			leftTalon1->Set(myCfg->LeftTalon1_MasterCANID);
		}

	}

	if (myCfg->LeftTalon2_Enabled)
	{
        if (myCfg->LeftTalon2_HasSensor)
        {
        	leftTalon2->SetFeedbackDevice(CANTalon::QuadEncoder);
        	leftTalon2->ConfigEncoderCodesPerRev(myCfg->QuadEncoder_CodesPerRev);
			if (myCfg->Left_SensorReversed)
			{
				leftTalon2->SetSensorDirection(true);
			} else
			{
				leftTalon2->SetSensorDirection(false);
			}
        }
        if (myCfg->LeftTalon2_EnablePID)
        {
        	leftTalon2->SelectProfileSlot(0);
        	leftTalon2->SetP(myCfg->Left_Profile_0_PID_P);
        	leftTalon2->SetI(myCfg->Left_Profile_0_PID_I);
        	leftTalon2->SetD(myCfg->Left_Profile_0_PID_D);
        	leftTalon2->SetF(myCfg->Left_Profile_0_PID_F);
			if (myCfg->Left_Profile_0_EnableCLRampRate)
			{
				leftTalon2->SetCloseLoopRampRate(myCfg->Left_Profile_0_CLRampRate);
			}

			leftTalon2->SetIzone(myCfg->Left_Profile_0_IZone);

			leftTalon2->SelectProfileSlot(1);
			leftTalon2->SetP(myCfg->Left_Profile_1_PID_P);
			leftTalon2->SetI(myCfg->Left_Profile_1_PID_I);
			leftTalon2->SetD(myCfg->Left_Profile_1_PID_D);
			leftTalon2->SetF(myCfg->Left_Profile_1_PID_F);
			if (myCfg->Left_Profile_1_EnableCLRampRate)
			{
				leftTalon2->SetCloseLoopRampRate(myCfg->Left_Profile_1_CLRampRate);
			}

			leftTalon2->SetIzone(myCfg->Left_Profile_1_IZone);
        }

		if(myCfg->EnableVoltRampRate)
		{
			leftTalon2->SetVoltageRampRate(myCfg->VoltRampRate);
			printf("Enabling Voltage Ramp Rate Left Talon 2 %f \n",myCfg->VoltRampRate);
		}

		if(myCfg->LeftTalon2_Slaved)
		{
			leftTalon2->SetControlMode(CANSpeedController::kFollower);
			leftTalon2->Set(myCfg->LeftTalon2_MasterCANID);
		}
	}

    if (myCfg->LeftTalon2_HasSensor)
    {
    	leftMaster = leftTalon2;
    	lmastCANID = myCfg->LeftTalon2_CANID;

    	leftSlave  = leftTalon1;
    	lslaveCANID = myCfg->LeftTalon1_CANID;
    } else
    {
    	leftMaster = leftTalon1;
    	lmastCANID = myCfg->LeftTalon1_CANID;

    	leftSlave  = leftTalon2;
    	lslaveCANID = myCfg->LeftTalon2_CANID;
    }

    if(myCfg->Left_Reversed)
    {
    	leftTalon1->SetInverted(true);
    	leftTalon2->SetInverted(true);
    }



// Right Side

	if (myCfg->RightTalon1_Enabled)
	{
        if (myCfg->RightTalon1_HasSensor)
        {
        	rightTalon1->SetFeedbackDevice(CANTalon::QuadEncoder);
        	rightTalon1->ConfigEncoderCodesPerRev(myCfg->QuadEncoder_CodesPerRev);
			if (myCfg->Right_SensorReversed)
			{
				rightTalon1->SetSensorDirection(true);
			} else
			{
				rightTalon1->SetSensorDirection(false);
			}
        }
        if (myCfg->RightTalon1_EnablePID)
        {
        	rightTalon1->SelectProfileSlot(0);
        	rightTalon1->SetP(myCfg->Right_Profile_0_PID_P);
        	rightTalon1->SetI(myCfg->Right_Profile_0_PID_I);
        	rightTalon1->SetD(myCfg->Right_Profile_0_PID_D);
        	rightTalon1->SetF(myCfg->Right_Profile_0_PID_F);
			if (myCfg->Right_Profile_0_EnableCLRampRate)
			{
				rightTalon1->SetCloseLoopRampRate(myCfg->Right_Profile_0_CLRampRate);
			}

			rightTalon1->SetIzone(myCfg->Right_Profile_0_IZone);

			rightTalon1->SelectProfileSlot(1);
			rightTalon1->SetP(myCfg->Right_Profile_1_PID_P);
			rightTalon1->SetI(myCfg->Right_Profile_1_PID_I);
			rightTalon1->SetD(myCfg->Right_Profile_1_PID_D);
			rightTalon1->SetF(myCfg->Right_Profile_1_PID_F);
			if (myCfg->Right_Profile_1_EnableCLRampRate)
			{
				rightTalon1->SetCloseLoopRampRate(myCfg->Right_Profile_1_CLRampRate);
			}

			rightTalon1->SetIzone(myCfg->Right_Profile_1_IZone);
        }

		if(myCfg->EnableVoltRampRate)
		{
			rightTalon1->SetVoltageRampRate(myCfg->VoltRampRate);
			printf("Enabling Voltage Ramp Rate Right Talon 1 %f \n",myCfg->VoltRampRate);
		}

		if(myCfg->RightTalon1_Slaved)
		{
			rightTalon1->SetControlMode(CANSpeedController::kFollower);
			rightTalon1->Set(myCfg->RightTalon1_MasterCANID);
		}
	}

	if (myCfg->RightTalon2_Enabled)
	{
        if (myCfg->RightTalon2_HasSensor)
        {
        	rightTalon2->SetFeedbackDevice(CANTalon::QuadEncoder);
        	rightTalon2->ConfigEncoderCodesPerRev(myCfg->QuadEncoder_CodesPerRev);
			if (myCfg->Right_SensorReversed)
			{
				rightTalon2->SetSensorDirection(true);
			} else
			{
				rightTalon2->SetSensorDirection(false);
			}
        }
        if (myCfg->RightTalon2_EnablePID)
        {
        	rightTalon2->SelectProfileSlot(0);
        	rightTalon2->SetP(myCfg->Right_Profile_0_PID_P);
        	rightTalon2->SetI(myCfg->Right_Profile_0_PID_I);
        	rightTalon2->SetD(myCfg->Right_Profile_0_PID_D);
        	rightTalon2->SetF(myCfg->Right_Profile_0_PID_F);
			if (myCfg->Right_Profile_0_EnableCLRampRate)
			{
				rightTalon2->SetCloseLoopRampRate(myCfg->Right_Profile_0_CLRampRate);
			}

			rightTalon2->SetIzone(myCfg->Right_Profile_0_IZone);

			rightTalon2->SelectProfileSlot(1);
			rightTalon2->SetP(myCfg->Right_Profile_1_PID_P);
			rightTalon2->SetI(myCfg->Right_Profile_1_PID_I);
			rightTalon2->SetD(myCfg->Right_Profile_1_PID_D);
			rightTalon2->SetF(myCfg->Right_Profile_1_PID_F);
			if (myCfg->Right_Profile_1_EnableCLRampRate)
			{
				rightTalon2->SetCloseLoopRampRate(myCfg->Right_Profile_1_CLRampRate);
			}

			rightTalon2->SetIzone(myCfg->Right_Profile_1_IZone);
        }

		if(myCfg->EnableVoltRampRate)
		{
			rightTalon2->SetVoltageRampRate(myCfg->VoltRampRate);
			printf("Enabling Voltage Ramp Rate Right Talon 2 %f \n",myCfg->VoltRampRate);
		}
		if(myCfg->RightTalon2_Slaved)
		{
			rightTalon2->SetControlMode(CANSpeedController::kFollower);
			rightTalon2->Set(myCfg->RightTalon2_MasterCANID);
		}
	}
	if (myCfg->RightTalon2_HasSensor)
	{
		rightMaster = rightTalon2;
		rmastCANID = myCfg->RightTalon2_CANID;

		rightSlave =  rightTalon1;
		rslaveCANID = myCfg->RightTalon1_CANID;
	} else
	{
		rightMaster = rightTalon1;
		rmastCANID = myCfg->RightTalon1_CANID;

		rightSlave  = rightTalon2;
		rslaveCANID = myCfg->RightTalon2_CANID;
	}

    if(myCfg->Right_Reversed)
    {
    	rightTalon1->SetInverted(true);
    	rightTalon2->SetInverted(true);
    }


    CANTalon::ControlMode rmmode = rightMaster->GetControlMode();

    switch (rmmode)
	{
    case CANSpeedController::kFollower:
    	printf("RMastMode Follower ");
    	break;

    case CANSpeedController::kPercentVbus:
    	printf("RMastMode PercentVbus ");
    	break;

    case CANSpeedController::kPosition:
    	printf("RMastMode Position ");
    	break;

    case CANSpeedController::kSpeed:
    	printf("RMastMode Speed ");
    	break;

    case CANSpeedController::kCurrent:
    	printf("RMastMode Current ");
    	break;

    case CANSpeedController::kVoltage:
    	printf("RMastMode Voltage ");
    	break;

    default:
    	printf("RMastMode %d ", rmmode);
    	break;
	}

    CANTalon::ControlMode rsmode = rightSlave->GetControlMode();
    switch (rsmode)
	{
    case CANSpeedController::kFollower:
    	printf("RSlaveMode Follower ");
    	break;

    case CANSpeedController::kPercentVbus:
    	printf("RSlaveMode PercentVbus ");
    	break;

    case CANSpeedController::kPosition:
    	printf("RSlaveMode Position ");
    	break;

    case CANSpeedController::kSpeed:
    	printf("RSlaveMode Speed ");
    	break;

    case CANSpeedController::kCurrent:
    	printf("RSlaveMode Current ");
    	break;

    case CANSpeedController::kVoltage:
    	printf("RSlaveMode Voltage ");
    	break;

    default:
    	printf("RSlaveMode %d ", rsmode);
    	break;
	}

    CANTalon::ControlMode lmmode = leftMaster->GetControlMode();
    switch (lmmode)
	{
    case CANSpeedController::kFollower:
    	printf("LMastMode Follower ");
    	break;

    case CANSpeedController::kPercentVbus:
    	printf("LMastMode PercentVbus ");
    	break;

    case CANSpeedController::kPosition:
    	printf("LMastMode Position ");
    	break;

    case CANSpeedController::kSpeed:
    	printf("LMastMode Speed ");
    	break;

    case CANSpeedController::kCurrent:
    	printf("LMastMode Current ");
    	break;

    case CANSpeedController::kVoltage:
    	printf("LMastMode Voltage ");
    	break;

    default:
    	printf("LMastMode %d ", lmmode);
    	break;
	}

    CANTalon::ControlMode lsmode = leftSlave->GetControlMode();
    switch (lsmode)
	{
    case CANSpeedController::kFollower:
    	printf("LSlaveMode Follower ");
    	break;

    case CANSpeedController::kPercentVbus:
    	printf("LSlaveMode PercentVbus ");
    	break;

    case CANSpeedController::kPosition:
    	printf("LSlaveMode Position ");
    	break;

    case CANSpeedController::kSpeed:
    	printf("LSlaveMode Speed ");
    	break;

    case CANSpeedController::kCurrent:
    	printf("LSlaveMode Current ");
    	break;

    case CANSpeedController::kVoltage:
    	printf("LSlaveMode Voltage ");
    	break;

    default:
    	printf("LSlaveMode %d ", lsmode);
    	break;
	}
    printf("\n");
}

void DriveTrain::LiveConfigure()
{
	RetrieveConfig();
	Configure();
	//turnController->LiveConfigure();
	//linearController->LiveConfigure();
}

void DriveTrain::Stop()
{
	leftTalon1->Disable();
	leftTalon2->Disable();
	rightTalon1->Disable();
	rightTalon2->Disable();
/* 	if (turnController->IsEnabled()) turnController->Disable();
	if (linearController->IsEnabled()) linearController->Disable();
	if (posPID.IsEnabled()) posPID.Disable();
	*/
	positioning = false;
	turning = false;
}

void DriveTrain::Set_PositionMode()
{
/*
	Zero_Encoders();

	leftTalon1->Set(lZeroPoint);
	leftTalon2->Set(lZeroPoint);
	rightTalon1->Set(rZeroPoint);
	rightTalon2->Set(rZeroPoint);


*/
	leftMaster->SelectProfileSlot(1);
	rightMaster->SelectProfileSlot(1);

	leftMaster->SetControlMode(CANSpeedController::kPosition);
	rightMaster->SetControlMode(CANSpeedController::kPosition);
	leftSlave->SetControlMode(CANSpeedController::kFollower);
	rightSlave->SetControlMode(CANSpeedController::kFollower);

	leftSlave->Set(lmastCANID);
	rightSlave->Set(rmastCANID);

	leftMaster->SetAllowableClosedLoopErr(myCfg->PID_CL_Allowable_Error);
	rightMaster->SetAllowableClosedLoopErr(myCfg->PID_CL_Allowable_Error);

	Zero_DriveEncoders();
	leftMaster->ClearError();
	rightMaster->ClearError();

	leftMaster->ClearIaccum();
	rightMaster->ClearIaccum();

	leftMaster->Set(0);
	rightMaster->Set(0);

	leftSlave->EnableControl();
	rightSlave->EnableControl();

	leftSlave->Enable();
    rightSlave->Enable();

	leftMaster->EnableControl();
	rightMaster->EnableControl();

    printf("Set_PositionMode ");
    CANTalon::ControlMode rmmode = rightMaster->GetControlMode();

    switch (rmmode)
	{
    case CANSpeedController::kFollower:
    	printf("RMastMode Follower ");
    	break;

    case CANSpeedController::kPercentVbus:
    	printf("RMastMode PercentVbus ");
    	break;

    case CANSpeedController::kPosition:
    	printf("RMastMode Position ");
    	break;

    case CANSpeedController::kSpeed:
    	printf("RMastMode Speed ");
    	break;

    case CANSpeedController::kCurrent:
    	printf("RMastMode Current ");
    	break;

    case CANSpeedController::kVoltage:
    	printf("RMastMode Voltage ");
    	break;

    default:
    	printf("RMastMode %d ", rmmode);
    	break;
	}

    CANTalon::ControlMode rsmode = rightSlave->GetControlMode();
    switch (rsmode)
	{
    case CANSpeedController::kFollower:
    	printf("RSlaveMode Follower ");
    	break;

    case CANSpeedController::kPercentVbus:
    	printf("RSlaveMode PercentVbus ");
    	break;

    case CANSpeedController::kPosition:
    	printf("RSlaveMode Position ");
    	break;

    case CANSpeedController::kSpeed:
    	printf("RSlaveMode Speed ");
    	break;

    case CANSpeedController::kCurrent:
    	printf("RSlaveMode Current ");
    	break;

    case CANSpeedController::kVoltage:
    	printf("RSlaveMode Voltage ");
    	break;

    default:
    	printf("RSlaveMode %d ", rsmode);
    	break;
	}

    CANTalon::ControlMode lmmode = leftMaster->GetControlMode();
    switch (lmmode)
	{
    case CANSpeedController::kFollower:
    	printf("LMastMode Follower ");
    	break;

    case CANSpeedController::kPercentVbus:
    	printf("LMastMode PercentVbus ");
    	break;

    case CANSpeedController::kPosition:
    	printf("LMastMode Position ");
    	break;

    case CANSpeedController::kSpeed:
    	printf("LMastMode Speed ");
    	break;

    case CANSpeedController::kCurrent:
    	printf("LMastMode Current ");
    	break;

    case CANSpeedController::kVoltage:
    	printf("LMastMode Voltage ");
    	break;

    default:
    	printf("LMastMode %d ", lmmode);
    	break;
	}

    CANTalon::ControlMode lsmode = leftSlave->GetControlMode();
    switch (lsmode)
	{
    case CANSpeedController::kFollower:
    	printf("LSlaveMode Follower ");
    	break;

    case CANSpeedController::kPercentVbus:
    	printf("LSlaveMode PercentVbus ");
    	break;

    case CANSpeedController::kPosition:
    	printf("LSlaveMode Position ");
    	break;

    case CANSpeedController::kSpeed:
    	printf("LSlaveMode Speed ");
    	break;

    case CANSpeedController::kCurrent:
    	printf("LSlaveMode Current ");
    	break;

    case CANSpeedController::kVoltage:
    	printf("LSlaveMode Voltage ");
    	break;

    default:
    	printf("LSlaveMode %d ", lsmode);
    	break;
	}
    printf("\n");

    if (rightMaster->IsEnabled()) printf("RightMaster Enabled ");
    if (rightSlave->IsEnabled()) printf("RightSlave Enabled ");
    if (leftMaster->IsEnabled()) printf("LeftMaster Enabled ");
    if (leftSlave->IsEnabled()) printf("LeftSlave Enabled ");
    printf("\n");
}

void DriveTrain::Set_VoltageMode()
{
	leftMaster->SelectProfileSlot(0);
	rightMaster->SelectProfileSlot(0);

	Zero_DriveEncoders();

    leftMaster->SetControlMode(CANSpeedController::kPercentVbus);
    rightMaster->SetControlMode(CANSpeedController::kPercentVbus);
	leftSlave->SetControlMode(CANSpeedController::kFollower);
	rightSlave->SetControlMode(CANSpeedController::kFollower);

	leftSlave->Set(lmastCANID);
	rightSlave->Set(rmastCANID);

	leftSlave->EnableControl();
	rightSlave->EnableControl();

	leftSlave->Enable();
	rightSlave->Enable();

    leftMaster->Set(0);
    rightMaster->Set(0);

    leftMaster->EnableControl();
    rightMaster->EnableControl();

    printf("Set_VoltageMode (percentVbus): ");
    CANTalon::ControlMode rmmode = rightMaster->GetControlMode();

    switch (rmmode)
	{
    case CANSpeedController::kFollower:
    	printf("RMastMode Follower ");
    	break;

    case CANSpeedController::kPercentVbus:
    	printf("RMastMode PercentVbus ");
    	break;

    case CANSpeedController::kPosition:
    	printf("RMastMode Position ");
    	break;

    case CANSpeedController::kSpeed:
    	printf("RMastMode Speed ");
    	break;

    case CANSpeedController::kCurrent:
    	printf("RMastMode Current ");
    	break;

    case CANSpeedController::kVoltage:
    	printf("RMastMode Voltage ");
    	break;

    default:
    	printf("RMastMode %d ", rmmode);
    	break;
	}

    CANTalon::ControlMode rsmode = rightSlave->GetControlMode();
    switch (rsmode)
	{
    case CANSpeedController::kFollower:
    	printf("RSlaveMode Follower ");
    	break;

    case CANSpeedController::kPercentVbus:
    	printf("RSlaveMode PercentVbus ");
    	break;

    case CANSpeedController::kPosition:
    	printf("RSlaveMode Position ");
    	break;

    case CANSpeedController::kSpeed:
    	printf("RSlaveMode Speed ");
    	break;

    case CANSpeedController::kCurrent:
    	printf("RSlaveMode Current ");
    	break;

    case CANSpeedController::kVoltage:
    	printf("RSlaveMode Voltage ");
    	break;

    default:
    	printf("RSlaveMode %d ", rsmode);
    	break;
	}

    CANTalon::ControlMode lmmode = leftMaster->GetControlMode();
    switch (lmmode)
	{
    case CANSpeedController::kFollower:
    	printf("LMastMode Follower ");
    	break;

    case CANSpeedController::kPercentVbus:
    	printf("LMastMode PercentVbus ");
    	break;

    case CANSpeedController::kPosition:
    	printf("LMastMode Position ");
    	break;

    case CANSpeedController::kSpeed:
    	printf("LMastMode Speed ");
    	break;

    case CANSpeedController::kCurrent:
    	printf("LMastMode Current ");
    	break;

    case CANSpeedController::kVoltage:
    	printf("LMastMode Voltage ");
    	break;

    default:
    	printf("LMastMode %d ", lmmode);
    	break;
	}

    CANTalon::ControlMode lsmode = leftSlave->GetControlMode();
    switch (lsmode)
	{
    case CANSpeedController::kFollower:
    	printf("LSlaveMode Follower ");
    	break;

    case CANSpeedController::kPercentVbus:
    	printf("LSlaveMode PercentVbus ");
    	break;

    case CANSpeedController::kPosition:
    	printf("LSlaveMode Position ");
    	break;

    case CANSpeedController::kSpeed:
    	printf("LSlaveMode Speed ");
    	break;

    case CANSpeedController::kCurrent:
    	printf("LSlaveMode Current ");
    	break;

    case CANSpeedController::kVoltage:
    	printf("LSlaveMode Voltage ");
    	break;

    default:
    	printf("LSlaveMode %d ", lsmode);
    	break;
	}
    printf("\n");

    if (rightMaster->IsEnabled()) printf("RightMaster Enabled ");
    if (rightSlave->IsEnabled()) printf("RightSlave Enabled ");
    if (leftMaster->IsEnabled()) printf("LeftMaster Enabled ");
    if (leftSlave->IsEnabled()) printf("LeftSlave Enabled ");
    printf("\n");

}

void DriveTrain::Zero_Encoders()
{
	lZeroPoint = leftMaster->GetPosition();
	rZeroPoint = rightMaster->GetPosition();

	lLastPosDelta = 0.0;
	rLastPosDelta = 0.0;
	hasMoved = false;
}

void DriveTrain::Zero_DriveEncoders()
{
	leftMaster->SetEncPosition(0);
	leftMaster->SetPosition(0.0);
	rightMaster->SetEncPosition(0);
	rightMaster->SetPosition(0.0);
	Zero_Encoders();
}

float DriveTrain::Limit(float num)
{
	if (num > 1.0)
	{
		return 1.0;
	}
	if (num < -1.0)
	{
		return -1.0;
	}
	return num;
}


bool DriveTrain::AtCommandedPosition()
{
	//if (!positioning) return true;
/*	double cpos = Master->GetPosition();
	double delta;

	if (cpos > distance)
	{
		delta = cpos - distance;
	} else
	{
		delta = distance - cpos;
	}

	//printf("sd:acp cpos %f distance %f cle %f poserr %d\n",cpos,distance, abs(cpos - distance),posErr);
	if (abs(delta) <= posErr )
	{
		printf("SD:ACP return cpos %f distance %f", cpos, distance);
		return true;
	}*/
	if (!yawLock)
	{
		double current = rightMaster->GetPosition();
		double lastSet = rightMaster->GetSetpoint();
		double delta;

		if (current > lastSet)
		{
			delta = current - lastSet;
		} else
		{
			delta = lastSet - current;
		}
		if (abs(delta) <= myCfg->PID_CL_Allowable_Error)
		{
			return true;
		}
		return false;
	} else
	{
		//return linearController->OnTarget();
		return true;
	}
	return false;
}

/*
 * Notes for Automodes
 * To turn only:
 * 1) Invoke Enable_Auto_Mode
 * 2) Invoke AutoDrive_Rotate in the execute and poll OnTarget in is finished.
 *
 * To move:
 * 1) Enable_Auto_Mode
 * 2) Invoke AutoDrive_SetYawLock(true)
 * 3)
 */



void DriveTrain::Enable_Auto_Mode()
{
	autoEnabled = true;
	Zero_DriveEncoders();
	Robot::sensorPkg->imu->ZeroYaw();
	Robot::sensorPkg->imu->ResetDisplacement();
}

void DriveTrain::AutoDrive_SetYawLock(bool lockYaw)
{
	yawLock = lockYaw;
	if (yawLock)
	{
		holdYaw = Robot::sensorPkg->imu->GetYaw();
		if (yawFlipped)
		{
			holdYaw = 0 - holdYaw;
		}
		/*
		turnController->SetSetpoint(holdYaw);
		turnController->Enable();
		*/
	} else
	{
		holdYaw = 0;
		//if (turnController->IsEnabled()) turnController->Disable();
	}
}

void DriveTrain::AutoDrive_Rotate(float rotate)
{
	if (!turning)
	{
		/*
		Zero_DriveEncoders();
		Robot::sensorPkg->imu->ZeroYaw();
		leftMaster->EnableControl();
		rightMaster->EnableControl();
		turnController->SetSetpoint(rotate);
		turnController->Enable();
		turning = true;
		*/
	}
}

bool DriveTrain::On_Target()
{
	//return turnController->OnTarget();
	return true;
}

double DriveTrain::Get_PulsesPerInch()
{
	return myCfg->QuadEncoder_CodesPerRev / myCfg->InchesPerRotation;
}

void DriveTrain::AutoDrive_SetDistance(float inches)
{
	float throttle = 0;
	if (!yawLock)
	{
		if (!positioning)
		{
			Zero_DriveEncoders();
			ldistance = (inches / myCfg->InchesPerRotation) * myCfg->QuadEncoder_CodesPerRev;
			if (myCfg->Left_SensorReversed || myCfg->Left_Reversed) ldistance = 0 - ldistance;

			rdistance = (inches / myCfg->InchesPerRotation) * myCfg->QuadEncoder_CodesPerRev;
			if (myCfg->Right_SensorReversed || myCfg->Right_Reversed) rdistance = 0 - rdistance;

			//if (leftMaster->GetPosition())


			printf("direct linear: set right %f  left %f \n",rdistance, ldistance);
			leftMaster->Set(ldistance);
			rightMaster->Set(rdistance);
			leftMaster->EnableControl();
			rightMaster->EnableControl();
			positioning = true;
		}
	} else
	{
		if (!positioning)
		{
			rdistance = (inches / myCfg->InchesPerRotation) * myCfg->QuadEncoder_CodesPerRev;
			if (myCfg->Right_SensorReversed) rdistance = 0 - rdistance;

			printf("yawlock linear: set %f  \n",rdistance);
			//linearController->SetSetpoint(rdistance);
			//linearController->Enable();
			//posPID.Enable();
			leftMaster->EnableControl();
			rightMaster->EnableControl();
			positioning = true;
		} else
		{
			//if (posPID.IsEnabled()) throttle = posPID.Get_Output();
			//SetDrive_Auto(lastturn, throttle);
		}
	}
}

void DriveTrain::AutoDrive_Move(float throttle)
{
	float limThrottle = Limit(throttle);

	if (rightMaster->GetControlMode() != CANSpeedController::kPercentVbus)
	{
		positioning = false;
		Set_VoltageMode();
	}

	leftMaster->Set(limThrottle);
	rightMaster->Set(limThrottle);
}

void DriveTrain::PIDWrite(float output)
{
	float turn = 0;
	float throttle = 0;

	//if (posPID.IsEnabled()) throttle = posPID.Get_Output();

	if (yawFlipped)
	{
		turn = 0 - output;
	} else
	{
		turn = output;
	}

	lastturn = turn;
	//SetDrive_Auto(turn, throttle);
}

double DriveTrain::Get_CurrentPosition()
{
	return rightMaster->GetPosition();
}


void DriveTrain::Disable_Auto_Mode()
{
	autoEnabled = false;
	//if (turnController->IsEnabled()) turnController->Disable();
	//if (linearController->IsEnabled()) linearController->Disable();
	//if (posPID.IsEnabled()) posPID.Disable();
	Set_VoltageMode();
    lastturn = 0;
	turning = false;
	positioning = false;
}

void DriveTrain::SetDriveType(DriveType type)
{
	myType = type;
	switch (myType)
	{
		case DriveType_Arcade:
			SmartDashboard::PutString("DriveType","Arcade");
			Preferences::GetInstance()->PutInt("DriveTrain::DriveType",(int) myType);
			break;
		case DriveType_Tank:
			SmartDashboard::PutString("DriveType","Tank");
			Preferences::GetInstance()->PutInt("DriveTrain::DriveType",(int) myType);
			break;

		case DriveType_Split:
			SmartDashboard::PutString("DriveType","Split");
			Preferences::GetInstance()->PutInt("DriveTrain::DriveType",(int) myType);
			break;
		default:
			SmartDashboard::PutString("DriveType","Invalid");
			break;
	}
}

void DriveTrain::SetDrive(XBOX_AxisState axisState)
{
	bool highspeed = false;
	if (axisState.RTrigger > 0.0)
	{
		highspeed = true;
	} else
	{
		highspeed = false;
	}


	//printf("lsx %f lsy %f  rsx %f rsy %f \n",axisState.Raw_LX, axisState.Raw_LY, axisState.Raw_RX,axisState.Raw_RY);
	switch (myType)
	{
	case DriveType_Arcade:
			Robot::driveTrain->SetDrive_Arcade(axisState.Raw_LX, axisState.Raw_LY, highspeed);
		break;

	case DriveType_Tank:
			Robot::driveTrain->SetDrive_Tank(axisState.Raw_LY, axisState.Raw_RY, highspeed);
			//Robot::driveTrain->SetDrive_Tank(axisState.Raw_RY, axisState.Raw_LY, highspeed);
		break;

	case DriveType_Split:
			Robot::driveTrain->SetDrive_Split(axisState.Raw_LX, axisState.Raw_RY, highspeed);
		break;

	default:

		break;
	}
}


void DriveTrain::SetDrive_Arcade(float x, float y, bool highRate)
{
	float tx, ty;

	tx = Limit(x);   // Left - / Right +
	ty = Limit(y);   // Forward + /Backward -

    printf("Arcade Drive: X %f : Y %f :: ",tx,ty);


	if (rightMaster->GetControlMode() != CANSpeedController::kPercentVbus)
	{
		positioning = false;
		Set_VoltageMode();
	}

	if (ty > 0.0)  // If moving forward
	{
		if (tx > 0.0) // If turning/rotating right
		{
			leftMotorOutput = ty - tx;
			rightMotorOutput = std::max(ty, tx);
		}
		else if (tx < 0.0) // If turning/rotating left or not moving
		{
			leftMotorOutput = std::max(ty, -tx);
			rightMotorOutput = ty + tx;
		} else
		{
			leftMotorOutput = ty;
			rightMotorOutput = ty;
		}
	}
	else  // If moving backward
	{
		if (tx > 0.0) // If turning/rotating right
		{
			leftMotorOutput = - std::max(-ty, tx);
			rightMotorOutput = ty + tx;
		}
		else if (tx < 0.0) // If turning/rotating left or not moving
		{
			leftMotorOutput = ty - tx;
			rightMotorOutput = - std::max(-ty, -tx);
		} else
		{
			leftMotorOutput = ty;
			rightMotorOutput = ty;
		}
	}

	if (highRate) // Technically high rate is the new slow for Stronghold.  Will change this in the off season.
	{
		leftMaster->Set(leftMotorOutput*myCfg->HighSpeed);
		rightMaster->Set(rightMotorOutput*myCfg->HighSpeed);
	} else
	{
		leftMaster->Set(leftMotorOutput*myCfg->LowSpeed);
		rightMaster->Set(rightMotorOutput*myCfg->LowSpeed);
	}
	float lt1v = leftTalon1->GetOutputVoltage();
	float lt1c = leftTalon1->GetOutputCurrent();
	float lt2v = leftTalon2->GetOutputVoltage();
	float lt2c = leftTalon2->GetOutputCurrent();
	float rt1v = rightTalon1->GetOutputVoltage();
	float rt1c = rightTalon1->GetOutputCurrent();
	float rt2v = rightTalon2->GetOutputVoltage();
	float rt2c = rightTalon2->GetOutputCurrent();
	float PDP0 = 0;
	float PDP1 = 0;
	float PDP14 = 0;
	float PDP15 = 0;
	if (RobotMap::pDPPowerDistributionPanel.get() != nullptr)
	{
		PDP0 = RobotMap::pDPPowerDistributionPanel->GetCurrent(0);
		PDP1 = RobotMap::pDPPowerDistributionPanel->GetCurrent(1);
		PDP14 = RobotMap::pDPPowerDistributionPanel->GetCurrent(14);
		PDP15 = RobotMap::pDPPowerDistributionPanel->GetCurrent(15);
	}
	printf(" l1(CAN 1/PDP 15) PdpC %f : V %f : C %f :: l2 (CAN 2/PDP 14) PdpC %f : V %f : C %f :: r1(CAN 3/PDP 0) PdpC %f : V %f : C %f :: r2(CAN 4/PDP 1) PdpC %f : V %f : C %f \n", PDP15, lt1v, lt1c, PDP14, lt2v, lt2c, PDP0, rt1v, rt1c, PDP1, rt2v, rt2c);

}


void DriveTrain::SetDrive_Tank(float left, float right, bool highRate)
{
	float tx, ty;

	tx = Limit(left);
	ty = Limit(right);

    printf("Tank Drive: Left %f : Right %f  :: ",tx,ty);

	if (rightMaster->GetControlMode() != CANSpeedController::kPercentVbus)
	{
		positioning = false;
		Set_VoltageMode();
	}

	leftMotorOutput = tx;
	rightMotorOutput = ty;

	if (highRate)  // Technically high rate is the new slow for Stronghold.  Will change this in the off season.
	{
		leftMaster->Set(leftMotorOutput*myCfg->HighSpeed);
		rightMaster->Set(rightMotorOutput*myCfg->HighSpeed);
	} else
	{
		leftMaster->Set(leftMotorOutput*myCfg->LowSpeed);
		rightMaster->Set(rightMotorOutput*myCfg->LowSpeed);
	}
	float lt1v = leftTalon1->GetOutputVoltage();
	float lt1c = leftTalon1->GetOutputCurrent();
	float lt2v = leftTalon2->GetOutputVoltage();
	float lt2c = leftTalon2->GetOutputCurrent();
	float rt1v = rightTalon1->GetOutputVoltage();
	float rt1c = rightTalon1->GetOutputCurrent();
	float rt2v = rightTalon2->GetOutputVoltage();
	float rt2c = rightTalon2->GetOutputCurrent();
	float PDP0 = 0;
	float PDP1 = 0;
	float PDP14 = 0;
	float PDP15 = 0;
	if (RobotMap::pDPPowerDistributionPanel.get() != nullptr)
	{
		PDP0 = RobotMap::pDPPowerDistributionPanel->GetCurrent(0);
		PDP1 = RobotMap::pDPPowerDistributionPanel->GetCurrent(1);
		PDP14 = RobotMap::pDPPowerDistributionPanel->GetCurrent(14);
		PDP15 = RobotMap::pDPPowerDistributionPanel->GetCurrent(15);
	}
	printf(" l1(CAN 1/PDP 15) PdpC %f : V %f : C %f :: l2 (CAN 2/PDP 14) PdpC %f : V %f : C %f :: r1(CAN 3/PDP 0) PdpC %f : V %f : C %f :: r2(CAN 4/PDP 1) PdpC %f : V %f : C %f \n", PDP15, lt1v, lt1c, PDP14, lt2v, lt2c, PDP0, rt1v, rt1c, PDP1, rt2v, rt2c);
}

void DriveTrain::SetDrive_Split(float turn, float throttle, bool highRate)
{
	float tx, ty;

	tx = Limit(turn);
	ty = Limit(throttle);

    printf("Split Drive: Turn %f : Throttle %f :: ",tx,ty);


	if (rightMaster->GetControlMode() != CANSpeedController::kPercentVbus)
	{
		positioning = false;
		Set_VoltageMode();
	}

	if (ty > 0.0) 			// If moving Forward
	{
		if (tx > 0.0)      // If turning/rotating right
		{
			leftMotorOutput = ty - tx;
			rightMotorOutput = std::max(ty, tx);
		}
		else if (tx < 0.0) // If turning/rotating left or not moving
		{
			leftMotorOutput = std::max(ty, -tx);
			rightMotorOutput = ty + tx;
		} else
		{
			leftMotorOutput = ty;
			rightMotorOutput = ty;
		}
	}
	else  // If Moving Backward
	{
		if (tx > 0.0) // If turning/rotating right
		{
			leftMotorOutput = - std::max(-ty, tx);
			rightMotorOutput = ty + tx;
		}
		else if (tx < 0.0) // If turning/rotating left or not moving
		{
			leftMotorOutput = ty - tx;
			rightMotorOutput = - std::max(-ty, -tx);
		} else
		{
			leftMotorOutput = ty;
			rightMotorOutput = ty;
		}
	}

	if (highRate) // Technically high rate is the new slow for Stronghold.  Will change this in the off season.
	{
		leftMaster->Set(leftMotorOutput*myCfg->HighSpeed);
		rightMaster->Set(rightMotorOutput*myCfg->HighSpeed);
	} else
	{
		leftMaster->Set(leftMotorOutput*myCfg->LowSpeed);
		rightMaster->Set(rightMotorOutput*myCfg->LowSpeed);
	}

	float lt1v = leftTalon1->GetOutputVoltage();
	float lt1c = leftTalon1->GetOutputCurrent();
	float lt2v = leftTalon2->GetOutputVoltage();
	float lt2c = leftTalon2->GetOutputCurrent();
	float rt1v = rightTalon1->GetOutputVoltage();
	float rt1c = rightTalon1->GetOutputCurrent();
	float rt2v = rightTalon2->GetOutputVoltage();
	float rt2c = rightTalon2->GetOutputCurrent();
	float PDP0 = 0;
	float PDP1 = 0;
	float PDP14 = 0;
	float PDP15 = 0;
	if (RobotMap::pDPPowerDistributionPanel.get() != nullptr)
	{
		PDP0 = RobotMap::pDPPowerDistributionPanel->GetCurrent(0);
		PDP1 = RobotMap::pDPPowerDistributionPanel->GetCurrent(1);
		PDP14 = RobotMap::pDPPowerDistributionPanel->GetCurrent(14);
		PDP15 = RobotMap::pDPPowerDistributionPanel->GetCurrent(15);
	}
	printf(" l1(CAN 1/PDP 15) PdpC %f : V %f : C %f :: l2 (CAN 2/PDP 14) PdpC %f : V %f : C %f :: r1(CAN 3/PDP 0) PdpC %f : V %f : C %f :: r2(CAN 4/PDP 1) PdpC %f : V %f : C %f \n", PDP15, lt1v, lt1c, PDP14, lt2v, lt2c, PDP0, rt1v, rt1c, PDP1, rt2v, rt2c);

}


void DriveTrain::SetDrive_Auto(float turn, float throttle)
{
	float tx, ty;

	tx = Limit(turn);
	ty = Limit(throttle);

    printf("Auto Drive: Turn %f  Throttle %f ::",tx,ty);


	if (rightMaster->GetControlMode() != CANSpeedController::kPercentVbus)
	{
		positioning = false;
		Set_VoltageMode();
	}

	if (ty > 0.0)
	{
		if (tx > 0.0)
		{
			leftMotorOutput = ty - tx;
			rightMotorOutput = std::max(ty, tx);
		}
		else if (tx < 0.0)
		{
			leftMotorOutput = std::max(ty, -tx);
			rightMotorOutput = ty + tx;
		} else
		{
			leftMotorOutput = ty;
			rightMotorOutput = ty;
		}
	}
	else
	{
		if (tx > 0.0)
		{
			leftMotorOutput = - std::max(-ty, tx);
			rightMotorOutput = ty + tx;
		}
		else if (tx < 0.0)
		{
			leftMotorOutput = ty - tx;
			rightMotorOutput = - std::max(-ty, -tx);
		} else
		{
			leftMotorOutput = ty;
			rightMotorOutput = ty;
		}
	}
	leftMaster->Set(leftMotorOutput);
	rightMaster->Set(rightMotorOutput);

	float lt1v = leftTalon1->GetOutputVoltage();
	float lt1c = leftTalon1->GetOutputCurrent();
	float lt2v = leftTalon2->GetOutputVoltage();
	float lt2c = leftTalon2->GetOutputCurrent();
	float rt1v = rightTalon1->GetOutputVoltage();
	float rt1c = rightTalon1->GetOutputCurrent();
	float rt2v = rightTalon2->GetOutputVoltage();
	float rt2c = rightTalon2->GetOutputCurrent();
	float PDP0 = 0;
	float PDP1 = 0;
	float PDP14 = 0;
	float PDP15 = 0;
	if (RobotMap::pDPPowerDistributionPanel.get() != nullptr)
	{
		PDP0 = RobotMap::pDPPowerDistributionPanel->GetCurrent(0);
		PDP1 = RobotMap::pDPPowerDistributionPanel->GetCurrent(1);
		PDP14 = RobotMap::pDPPowerDistributionPanel->GetCurrent(14);
		PDP15 = RobotMap::pDPPowerDistributionPanel->GetCurrent(15);
	}
	printf(" l1(CAN 1/PDP 15) PdpC %f : V %f : C %f :: l2 (CAN 2/PDP 14) PdpC %f : V %f : C %f :: r1(CAN 3/PDP 0) PdpC %f : V %f : C %f :: r2(CAN 4/PDP 1) PdpC %f : V %f : C %f \n", PDP15, lt1v, lt1c, PDP14, lt2v, lt2c, PDP0, rt1v, rt1c, PDP1, rt2v, rt2c);

}
