// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "Intake.h"
#include "../RobotMap.h"
#include "../Robot.h"


Intake::Intake() : Subsystem("Intake") , Configurable("Intake") {

    intakeTalon = RobotMap::intakeTalon;
    myCfg.reset(&(Robot::theConfig->_IntakeCfg));

	Configure();

}

void Intake::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
	//SetDefaultCommand(new Pivot_Stick());
}


// Put methods for controlling this subsystem
// here. Call these from Commands.

Intake::~Intake()
{

}

void Intake::RetrieveConfig()
{

}

void Intake::Configure()
{
	if (myCfg->Talon_Enabled)
	{
		if(myCfg->Talon_EnableVoltRampRate)
		{
			intakeTalon->SetVoltageRampRate(myCfg->Talon_VoltRampRate);
		}
	}
}

void Intake::LiveConfigure()
{
	RetrieveConfig();
	Configure();
}


void Intake::SaveConfig()
{

}


void Intake::SetIntake(bool in, float percent_speed)
{
	if (in)
	{
		intakeTalon->Set(myCfg->InSpeed * percent_speed);
	} else
	{
		intakeTalon->Set(myCfg->OutSpeed * percent_speed);
	}
}

void Intake::StopIntake()
{
	intakeTalon->Set(0);
}


float Intake::Limit(float num)
{
	if (num > 0.50)
	{
		return 0.50;
	}
	if (num < -0.50)
	{
		return -0.50;
	}
	return num;
}

bool Intake::RobotHasBall(bool shooting)
{
	if (Robot::sensorPkg->Is_FrontOveridden())
	{
		// If sensor has been overidden and we are shooting
		// then tell the fire command that we still have a ball.
		// This will force the shooter to stay spinning until timeout.
		if (shooting) return true;
		return false;
	}

	if (Robot::sensorPkg->RobotHasBall(shooting))
	{
		return true;
	}
	return false;
}

bool Intake::IsBallAtShooter()
{
	// If sensor is overidden then report false.
	if (Robot::sensorPkg->Is_ShooterOveridden()) return false;
	if (Robot::sensorPkg->IsBallAtShooter())
	{
		return true;
	}
	return false;
}

float Intake::Get_PreFireOut(){
	return myCfg->PreFireOut;
}
