// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Shooter.h"
#include "../RobotMap.h"
#include "../Robot.h"
#include "../Commands/Shoot.h"
//#define DEFLECTOR_NOTPRESENT


Shooter::Shooter() : Subsystem("Shooter") , Configurable("Shooter") {
    TopTalon    = RobotMap::shooterTopTalon;
    BottomTalon = RobotMap::shooterBottomTalon;


#ifdef DEFLECTOR_NOTPRESENT

#else
    deflector = RobotMap::deflectorSolenoid;
#endif

    isConfigured = false;
    myCfg.reset(&(Robot::theConfig->_ShooterCfg));


	Configure();
    isShooting = false;
    stallCheck = 0;
}

void Shooter::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    SetDefaultCommand(new Shoot());
}


// Put methods for controlling this subsystem
// here. Call these from Commands.

Shooter::~Shooter()
{

}

void Shooter::RetrieveConfig()
{

}

void Shooter::Configure()
{
	if (myCfg->TopTalon_Enabled)
	{
		printf("Shooter Top is set to enabled. CANID %d\n",myCfg->TopTalon_CANID);
        if (myCfg->TopTalon_HasSensor)
        {
    		printf("Shooter Top configured to have Sensor\n");
        	TopTalon->SetFeedbackDevice(CANTalon::CtreMagEncoder_Relative);
			if (myCfg->TopTalon_SensorReversed)
			{
				printf("Shooter Top Sensor is set to Reversed\n");
				TopTalon->SetSensorDirection(true);
			} else
			{
				TopTalon->SetSensorDirection(false);
			}
        }
        if (myCfg->TopTalon_EnablePID)
        {
        	printf("Warning: Shooter Top PID is enabled\n");
        }

		if(myCfg->TopTalon_EnableVoltRampRate)
		{
			printf("Shooter Top has volt ramp rate %f\n",myCfg->TopTalon_VoltRampRate);
			TopTalon->SetVoltageRampRate(myCfg->TopTalon_VoltRampRate);
		}

		if(myCfg->TopTalon_Slaved)
		{
			printf("Shooter Top is slaved to CANID %d\n",myCfg->TopTalon_MasterCANID);
			TopTalon->SetControlMode(CANSpeedController::kFollower);
			TopTalon->Set(myCfg->TopTalon_MasterCANID);
			master = BottomTalon;
			slave = TopTalon;
		}
		TopTalon->ClearStickyFaults();
	}

	if (myCfg->BottomTalon_Enabled)
	{
		printf("Shooter Bottom is set to enabled. CANID %d\n",myCfg->BottomTalon_CANID);
        if (myCfg->BottomTalon_HasSensor)
        {
        	printf("Shooter Bottom configured with Sensor\n");
        	BottomTalon->SetFeedbackDevice(CANTalon::CtreMagEncoder_Relative);

			if (myCfg->BottomTalon_SensorReversed)
			{
				printf("Shooter Bottom Sensor set to Reversed\n");
				BottomTalon->SetSensorDirection(true);
			} else
			{
				BottomTalon->SetSensorDirection(false);
			}
        }
        if (myCfg->BottomTalon_EnablePID)
        {
        	printf("Shooter Bottom is PID enabled\n");
        	BottomTalon->SelectProfileSlot(0);
        	BottomTalon->SetP(myCfg->BottomTalon_Profile_0_PID_P);
        	BottomTalon->SetI(myCfg->BottomTalon_Profile_0_PID_I);
        	BottomTalon->SetD(myCfg->BottomTalon_Profile_0_PID_D);
        	BottomTalon->SetF(myCfg->BottomTalon_Profile_0_PID_F1);
        	printf("Profile 0) P: %f I: %f D: %f F: %f\n",myCfg->BottomTalon_Profile_0_PID_P,myCfg->BottomTalon_Profile_0_PID_I,
        			myCfg->BottomTalon_Profile_0_PID_D, myCfg->BottomTalon_Profile_0_PID_F1);

			if (myCfg->BottomTalon_Profile_0_EnableCLRampRate)
			{
				printf("Shooter Bottom has Close Loop Ramp Rate enabled with rate setting %f\n",myCfg->BottomTalon_Profile_0_CLRampRate);
				BottomTalon->SetCloseLoopRampRate(myCfg->BottomTalon_Profile_0_CLRampRate);
			}
			printf("Shooter Bottom has IZone setting of %d\n",myCfg->BottomTalon_Profile_0_IZone);
			BottomTalon->SetIzone(myCfg->BottomTalon_Profile_0_IZone);
        }

		if(myCfg->BottomTalon_EnableVoltRampRate)
		{
			printf("Shooter Bottom has volt ramp rate %f\n",myCfg->BottomTalon_VoltRampRate);
			BottomTalon->SetVoltageRampRate(myCfg->BottomTalon_VoltRampRate);
		}
		if(myCfg->BottomTalon_Slaved)
		{
			printf("Warning: Shooter Bottom is slaved to CANID %d\n",myCfg->BottomTalon_MasterCANID);
			BottomTalon->SetControlMode(CANSpeedController::kFollower);
			BottomTalon->Set(myCfg->BottomTalon_MasterCANID);
			master = TopTalon;
			slave = BottomTalon;
		}
		BottomTalon->ClearStickyFaults();
	}

	master->ConfigNominalOutputVoltage(0.0,0.0);

	// Prevent shooter from attempting to reverse direction to slow down in Closed Loop.
	// Wild swings in the direction of rotation can damage motors and electronics due
	// the potential overdrive by the talon to overcome the rotational inertia of the flywheel

	if (myCfg->Speed1 < 0 )
	{
		// desired rotation is in negative RPM.
	    master->ConfigPeakOutputVoltage(0.0,-12.0);
	} else
	{
		// desired rotation is in positive RPM.
		master->ConfigPeakOutputVoltage(12.0,0.0);
	}

	printf("Shooter setting control mode to speed\n");
	master->SetControlMode(CANSpeedController::kSpeed);
	isConfigured = true;

	if (Is_SensorPresent())
	{
		printf("Shooter Master confirmed sensor present\n");
	} else
	{
		printf("Warning: Shooter Master reported sensor not present\n");
	}
}

bool Shooter::Is_SensorPresent()
{
	if (isConfigured)
	{
		CANTalon::FeedbackDeviceStatus status = master->IsSensorPresent(CANTalon::CtreMagEncoder_Relative);
		return (CANTalon::FeedbackStatusPresent == status);
	}
	return false;
}


void Shooter::SaveConfig()
{
}

void Shooter::LiveConfigure()
{
	RetrieveConfig();
	Configure();
}

float Shooter::Fire(bool pos1)
{
	if (isConfigured)
	{
		if (!isShooting)
		{
			printf("Shooting \n");
			Raise_Deflector();
		}
		if (myCfg->UseSpeed)
		{
			return FireSpeed(pos1);
		} else
		{
			return FireVolt(pos1);
		}
	}
	return 0;
}


void Shooter::FireVal(float value)
{
	if (!isShooting)
	{
		Raise_Deflector();
        master->ClearIaccum();
		master->SetControlMode(CANSpeedController::kSpeed);
	    master->EnableControl();
	    slave->EnableControl();
	}
	BottomTalon->Set(value);
	tgtRPM = value;
	SmartDashboard::PutNumber("Shooter Firing RPM",tgtRPM);
	isShooting = true;
}

float Shooter::FireSpeed(bool pos1)
{
	// To tune PID for velocity zero all PID values and then
	// adjust FeedForward while watching the RPM.
	// FeedForward sets the base level that PID will work from.
	// Adjust P to change how fast the controller responds to error.
	if (!isShooting)
	{
		Raise_Deflector();
        master->ClearIaccum();
		master->SetControlMode(CANSpeedController::kSpeed);
	    master->EnableControl();
	    slave->EnableControl();

		if (pos1)
		{
			master->SetF(myCfg->BottomTalon_Profile_0_PID_F1);
			tgtRPM = myCfg->Speed1;
		} else
		{
			master->SetF(myCfg->BottomTalon_Profile_0_PID_F2);
			tgtRPM = myCfg->Speed2;
		}
	}
	master->Set(tgtRPM);
	isShooting = true;
	return tgtRPM;
}

float Shooter::FireVolt(bool pos1)
{
	if (!isShooting)
	{
		Raise_Deflector();
		master->SetControlMode(CANSpeedController::kPercentVbus);
		if (pos1)
		{
			master->SetF(myCfg->BottomTalon_Profile_0_PID_F1);
			tgtVolt = myCfg->PercentVoltage1;
		} else
		{
			master->SetF(myCfg->BottomTalon_Profile_0_PID_F2);
			tgtVolt = myCfg->PercentVoltage2;
		}
		master->EnableControl();
	    slave->EnableControl();
	}
    master->Set(tgtVolt);
	isShooting = true;
	return tgtVolt;
}

bool Shooter::Is_Stalling()
{
	float rpm = master->GetSpeed();

	if (fabs(rpm) <= myCfg->StallRPM_Threshold)
	{
		printf("Shooter_IS RPM: %f returning true\n",rpm);
		return true;
	}
	printf("Shooter_IS RPM: %f return false\n",rpm);
	return false;
}

bool Shooter::ReadyToFire()
{
	if (myCfg->UseSpeed)
	{
		return AtRPM();
	} else
	{
		return AtVolt();
	}
}

bool Shooter::AtRPM()
{
	SmartDashboard::PutNumber("Shooter RPM",BottomTalon->GetSpeed());
	float t2, r;
	r = fabs(master->GetSpeed());
	t2 = fabs(tgtRPM);

	if (r >= t2) return true;
	return false;
}

bool Shooter::AtVolt()
{
	SmartDashboard::PutNumber("Shooter Volt",BottomTalon->GetOutputVoltage());
	if (tgtVolt < 0)
	{
		if (BottomTalon->GetOutputVoltage() <= tgtVolt)
		{
			return true;
		}
	} else
	{
		if (BottomTalon->GetOutputVoltage() >= tgtVolt)
		{
			return true;
		}
	}
	return false;
}


bool Shooter::IsShooting()
{
	return isShooting;
}

void Shooter::Stop()
{
	stallCheck = 0;
	BottomTalon->Set(0);
	BottomTalon->StopMotor();
	tgtRPM = 0;
	tgtVolt = 0;
	isShooting = false;
	printf("Shooter stop \n");
	Lower_Deflector();
}




void Shooter::Raise_Deflector()
{
#ifdef DEFLECTOR_NOTPRESENT

#else
	if (myCfg->Deflector_ActiveIsFolded)
	{
		printf("Raising Deflector true \n");
		deflector->Set(false);
	} else
	{
		printf("Raising Deflector false \n");
		deflector->Set(true);
	}
#endif
}

void Shooter::Lower_Deflector()
{
#ifdef DEFLECTOR_NOTPRESENT

#else
	if (myCfg->Deflector_ActiveIsFolded)
	{
		printf("Lowering Deflector true \n");
		deflector->Set(true);
	} else
	{
		printf("Lowering Deflector false \n");
		deflector->Set(false);
	}
#endif
}

bool Shooter::Is_DeflectorRaised()
{
#ifdef DEFLECTOR_NOTPRESENT
	return false;
#else

	if (myCfg->Deflector_ActiveIsFolded)
	{
		if (deflector->Get()) return false;
		return true;
	} else
	{
		if (deflector->Get()) return true;
		return false;
	}
	return false;
#endif
}
