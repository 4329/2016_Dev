// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "Sensors.h"
#include "../RobotMap.h"
#include "../Robot.h"



Sensors::Sensors() : Subsystem("Sensors"), Configurable("Sensors") {
	printf("Sensors Start\n");
    myCfg.reset(&(Robot::theConfig->_SensorCfg));

    IR_Front.reset( new IR_Sensor(RobotMap::sensorIRdSensorFront, myCfg->Front_distThreshold, "IR_Sensor::Front"));
    IR_Shooter.reset( new IR_Sensor(RobotMap::sensorIRdSensor, myCfg->Shooter_distThreshold, "IR_Sensor::Shooter"));
    IR_Tower.reset(new IR_Sensor(RobotMap::sensorIRdSensorTower, myCfg->Tower_distThreshold, "IR_Sensor::Tower"));
    pressure = RobotMap::pressureSensor;
    _pDp = RobotMap::pDPPowerDistributionPanel;
    imu.reset(new IMU(myCfg->_IMUcfg));

    ShooterOveride = false;
    FrontOveride = false;

	Configure();
}
    
Sensors::~Sensors()
{

}

void Sensors::RetrieveConfig()
{
	IR_Front->RetrieveConfig();
	IR_Shooter->RetrieveConfig();
	IR_Tower->RetrieveConfig();
	imu->RetrieveConfig();

}

void Sensors::SaveConfig()
{
	IR_Front->SaveConfig();
	IR_Shooter->SaveConfig();
	IR_Tower->SaveConfig();
	imu->SaveConfig();
}

void Sensors::Configure()
{
	IR_Front->Configure();
	IR_Shooter->Configure();
	IR_Tower->Configure();
	imu->Configure();
}

void Sensors::LiveConfigure()
{
	RetrieveConfig();
	IR_Front->LiveConfigure();
	IR_Shooter->LiveConfigure();
	IR_Tower->LiveConfigure();
	imu->LiveConfigure();
}


void Sensors::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//SetDefaultCommand(new MySpecialCommand());
}

float Sensors::GetTowerInRangeRumble()
{
	return myCfg->TowerInRangeRumble;
}

bool Sensors::RobotHasBall(bool shooting)
{
	if (FrontOveride)
	{
		// If sensor has been overidden and we are shooting
		// then tell the fire command that we still have a ball.
		// This will force the shooter to stay spinning until timeout.
		if (shooting) return true;
		return false;
	}
	if (IR_Front->IsInRange())
	{
		return true;
	}
	return false;
}

bool Sensors::IsBallAtShooter()
{
	if (ShooterOveride) return false;
	if (IR_Shooter->IsInRange())
	{
		return true;
	}
	return false;
}

void Sensors::Set_ShooterOveride(bool overide)
{
	ShooterOveride = overide;
}

bool Sensors::Is_ShooterOveridden()
{
	return ShooterOveride;
}

void Sensors::Set_FrontOveride(bool overide)
{
	FrontOveride = overide;
}

bool Sensors::Is_FrontOveridden()
{
	return FrontOveride;
}

bool Sensors::TowerInRange()
{
	if (IR_Tower->IsInRange())
	{
		return true;
	}
	return false;
}

float Sensors::GetAirPressure()
{
	float vout = pressure->GetVoltage();
	return (250.0 *(vout/5.0) - 25.0);
}

bool Sensors::IsPivotAtHome()
{
	return false;
}

bool Sensors::IsPivotAtIntake()
{
	return false;
}

bool Sensors::IsPivotAtLow()
{
	return false;
}

void Sensors::SetFrontIn()
{
	IR_Front->SetIn();
}

void Sensors::SetFrontOut()
{
	IR_Front->SetOut();
}

void Sensors::SetShooterIn()
{
	IR_Shooter->SetIn();
}

void Sensors::SetShooterOut()
{
	IR_Shooter->SetOut();
}

void Sensors::StoreCalibration()
{
	IR_Front->StoreCalibration();
	IR_Shooter->StoreCalibration();
}
