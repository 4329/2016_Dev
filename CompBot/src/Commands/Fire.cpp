// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Fire.h"
#include "../Robot_Config.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

Fire::Fire(bool pos1): Command() {
	Requires(Robot::shooter.get());
	Requires(Robot::intake.get());
    shot = false;
    TimeOut = 5.0;
	hasStalled = false;
	abort = false;
	isPos1 = pos1;
	stall = 0;
}


// Called just before this Command runs the first time
void Fire::Initialize() {
	// Retrieve the command timeout for shooting the ball.
	TimeOut = Robot::theConfig->_ShooterCfg.Fire_Timeout;

	// Set the timeout.
	SetTimeout(TimeOut);

	// Initialize default state variables.
	hasStalled = false;
	abort = false;
	stall = 0;

	SmartDashboard::PutBoolean("Shot Aborted",false);
	SmartDashboard::PutBoolean("Auto Expel",false);
}

// Called repeatedly when this Command is scheduled to run
void Fire::Execute() {
    // Tell the shooter to fire based on left or right trigger (associated with a fire config)
	float tgt = Robot::shooter->Fire(isPos1);

	// If this is the first execution, specify what the target setpoint is.
	if (!shot) SmartDashboard::PutNumber("Shooter Firing SetPoint",tgt);

    // If stall has been detected 5 times in a row, report to dashboard.
	if (stall == 5) SmartDashboard::PutBoolean("Shooter Stalled",true);

	// If stall continues, take action.
	if (stall > 5)
	{
		// First action is the default action.  Back out the ball in
		// preparation to fire.  (Nominal case)
		if (!hasStalled)
		{
			printf("Shooter stall detected. Expelling ball.\n");
			SmartDashboard::PutBoolean("Auto Expel",true);
		}

		// Set a state variable.
		hasStalled = true;

		// Command the ball away from the shooter.
		Robot::intake->SetIntake(false,Robot::intake->Get_PreFireOut());
	}

	if (hasStalled)
	{
		// if we detected stalling the last execution,
		// lets see if moving the ball back has resolved the problem.
		if (stall == 0)
		{
			// if no longer stalling then stop the intake.
			Robot::intake->StopIntake();
			hasStalled = false;
			printf("Stall has been resolved. Proceeding with shot.\n");
			SmartDashboard::PutBoolean("Shooter Stalled",false);
			SmartDashboard::PutBoolean("Auto Expel",false);
		}

		// If stall has lasted for approximately 2 seconds abort
		// the shot to protect the motors.
		if (stall >= 100) // 100 = 100 * 0.020ms = 2secs
		{
			// if stalled for 2 seconds abort the shot.
			abort = true;
			printf("Aborting shot due to shooter stall\n");
			SmartDashboard::PutBoolean("Shot Aborted",true);
		}
	}

    // Lets check if the shooter has reached firing RPM.
	if (Robot::shooter->ReadyToFire())
	{
		printf("Shooter ready to fire. Driving ball into shooter\n");

		// If we still have the ball continue to push the ball into the shooter wheel.
		if (Robot::sensorPkg->RobotHasBall())
		{
			Robot::intake->SetIntake(true);
		}
	}
	// Indicate we are past the first execution.
	shot = true;
}

// Make this return true when this Command no longer needs to run execute()
bool Fire::IsFinished() {
	// Check if the shooter is stalling.
	if (Robot::shooter->Is_Stalling())
	{
		stall++;  // If it is increase the stall count.
	} else
	{
		// If not set stall to 0 and cancel abort.
		stall = 0;
		abort = false;
	}
	if (abort) return true;  // If abort commanded indicate finished.

	if (IsTimedOut()) return true;  // Fire has timed out.

	if (stall > 0) return false;  // If not aborted and stall is being indicated then continue.
    if (Robot::sensorPkg->RobotHasBall())
   	{
   	   return false;  // If the robot still is in possession of the ball then continue.
   	}
    return true;  // Otherwise the shot is complete.
}

// Called once after isFinished returns true
void Fire::End() {
	// Update status on dashboard.
	SmartDashboard::PutBoolean("Shooting",false);
	SmartDashboard::PutBoolean("Auto Expel",false);
	// Spin down the shooter.
	Robot::shooter->Stop();

	// Stop the intake.
	Robot::intake->StopIntake();

	// Reset state
	shot = false;
	hasStalled = false;
	abort = false;
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void Fire::Interrupted() {
	End();
}
