// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "Video.h"
#include "RobotMap.h"


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES


Video::Video() {
}
    

bool Video::Init(VideoCfg *config,XBOX360_Controller *controller)
{
	myConfig = config;
	myController = controller;
	currentUpdate = myConfig->configUpdateCount;
    frontCam.reset(new USBCamera(myConfig->FrontName.c_str(),true));
    rearCam.reset(new USBCamera(myConfig->RearName.c_str(),true));
    frame = imaqCreateImage(IMAQ_IMAGE_RGB, 0);
	return true;
}

void Video::Run(){
	server = CameraServer::GetInstance();

	LiveConfigure();
	SelectFront();

	while (!myConfig->StopCapture)
	{
		// Check for a camera toggle
		if (myController->Get_ButtonState().LeftBumper) ToggleView();
		ProcessStream();
		if (myConfig->configUpdateCount > currentUpdate) LiveConfigure();
	}
}

void Video::ProcessStream()
{
	if (FrontActive)
	{
		frontCam->GetImage(frame);

	} else
	{
		rearCam->GetImage(frame);
	}
	server->SetImage(frame);
}

void Video::LiveConfigure()
{
	currentUpdate = myConfig->configUpdateCount;

}


void Video::ToggleView()
{
	if (FrontActive)
	{

		SelectRear();
	} else
	{

		SelectFront();
	}
}

void Video::SelectFront()
{
	if (myConfig->FrontEnable)
	{
		printf("Selecting Front Camera\n");

	if (!FrontActive)
	{
		rearCam->StopCapture();
		rearCam->CloseCamera();
		frontCam->OpenCamera();
	}
	frontCam->SetFPS(myConfig->FrontFPS);
	if (myConfig->FrontExpAuto)
	{
		frontCam->SetExposureAuto();
	} else
	{
		frontCam->SetExposureManual(myConfig->FrontExp);
	}
	if (myConfig->FrontWBAuto)
	{
		frontCam->SetWhiteBalanceAuto();
	} else
	{
		frontCam->SetWhiteBalanceManual(myConfig->FrontWB);
	}
		frontCam->SetBrightness(myConfig->FrontBrightness);
		//frontCam->SetSize(myConfig->FrontWidth,myConfig->FrontHeight);
		frontCam->StartCapture();
		FrontActive = true;
	} else
	{
		printf("Front Camera not Enabled\n");
	}
}

bool Video::IsFrontSelected()
{
	return FrontActive;
}

void Video::SelectRear()
{
	if (myConfig->RearEnable)
	{
		printf("Selecting Rear Camera\n");
		if (FrontActive)
		{
			frontCam->StopCapture();
			frontCam->CloseCamera();
			rearCam->OpenCamera();
		}
		FrontActive = false;
		rearCam->SetFPS(myConfig->RearFPS);
		if (myConfig->RearExpAuto)
		{
			rearCam->SetExposureAuto();
		} else
		{
			rearCam->SetExposureManual(myConfig->RearExp);
		}
		if (myConfig->RearWBAuto)
		{
			rearCam->SetWhiteBalanceAuto();
		} else
		{
			rearCam->SetWhiteBalanceManual(myConfig->RearWB);
		}
		rearCam->SetBrightness(myConfig->RearBrightness);
		//rearCam->SetSize(myConfig->RearWidth,myConfig->RearHeight);
		rearCam->StartCapture();
	} else
	{
		printf("Rear Camera not enabled\n");
	}
}

bool Video::IsRearSelected()
{
	return !FrontActive;
}

void Video::End()
{

}
